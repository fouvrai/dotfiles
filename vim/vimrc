
""""""""""""""""""""""""""""""""""""""""""""""""""
" General
"

" behave less like vi (i.e. more vim features)
set nocompatible

" behave like windows instead of xterm
source $VIMRUNTIME/mswin.vim

" don't dump swap files in cwd
set directory-=.
set directory+=$TEMP

" load filetype plugins
filetype plugin on

""""""""""""""""""""""""""""""""""""""""""""""""""
" Pathogen
"

" set up pathogen runtime path manipulation
runtime bundle/pathogen/autoload/pathogen.vim
call pathogen#infect()

""""""""""""""""""""""""""""""""""""""""""""""""""
" GUI
"

" use my screen real estate
set lines=60
set columns=120

" minimize the gui
set guioptions=r

""""""""""""""""""""""""""""""""""""""""""""""""""
" Fonts & Colors
"

" turn on syntax highlighting
syntax on

" use a better font
set guifont=Consolas:h9

" set the default color scheme
set background=dark
" let g:solarized_contrast="high"
colorscheme solarized
" colorscheme jColor

" set console colors
if !has("gui_running")
    colorscheme default
endif

""""""""""""""""""""""""""""""""""""""""""""""""""
" Tabs
"

" copy indent from current line when starting a new line
" except in cases like following a {
set autoindent
set smartindent

" smartindent does weird things with #
inoremap # X#

" tabs are 4 spaces
set tabstop=4

" tabs feel like 4 spaces
set softtabstop=4

" autoindents are 4 spaces
set shiftwidth=4

" use spaces instead of tabs
set expandtab

""""""""""""""""""""""""""""""""""""""""""""""""""
" User Interface
"

" don't wrap lines
set nowrap

" show line numbers
set number

" show tabs and trailing spaces
set listchars=tab:»·,trail:•
set list

" flash matched parentheses, brackets, and braces
set showmatch

" flash instead of beep for errors
set visualbell

" don't redraw when running macros
set lazyredraw

" change the default status line
" and always display it
set statusline=%t\ [%Y%M%R]\ CWD=%{getcwd()}%=%-14.(Line:\%l/%L%)\ %-7.(Col:%3c%)
set laststatus=2

" show matches for command completion
set wildmenu

" show the popup even for just one match
set completeopt=menu,menuone,preview

""""""""""""""""""""""""""""""""""""""""""""""""""
" Movement
"

" keep four lines when scrolling
set scrolloff=3

" move freely between lines
set whichwrap+=<,>,[,],h,l

" allow backspacing over everything in insert mode
set backspace=indent,eol,start

""""""""""""""""""""""""""""""""""""""""""""""""""
" Searching
"

" make searches case insensitive
" unless they're mixed case
set ignorecase
set smartcase

" search while typing
set incsearch

" do not highlight the last used search term
set nohlsearch

" by default we want substitutions to occur in the entire line
set gdefault

""""""""""""""""""""""""""""""""""""""""""""""""""
" Files
"

" allow switching buffers without saving
set hidden

" automatically set our working dir to the current file
set autochdir

""""""""""""""""""""""""""""""""""""""""""""""""""
" Mappings
"

" comma leader is much more handy
let mapleader=','

" edit this file
noremap  <C-F1>      :e ~/vimfiles/vimrc<CR>
inoremap <C-F1> <C-O>:e ~/vimfiles/vimrc<CR>
vnoremap <C-F1> <C-C>:e ~/vimfiles/vimrc<CR>

" when text is selected, tab and shift-tab should indent
vnoremap > >gv
vnoremap < <gv

" ctrl-tab and ctrl-shift-tab should switch buffers
" noremap <C-TAB>   :bnext<CR>
" noremap <C-S-TAB> :bprevious<CR>

" inoremap <C-TAB>   <ESC>:bnext<CR>
" inoremap <C-S-TAB> <ESC>:bprevious<CR>

" ctrl+w should close the buffer
function! DeleteCurrentBuffer()
    " get the current window and buffer
    let l:bufnr = bufnr("%")
    let l:winnr = winnr("$")

    " delete the buffer
    bd

    " if we're still in the same window, make sure we went to the right buffer
    if winnr("$") == l:winnr
        " reload the old buffer, and go to the next buffer
        exec "b  " . l:bufnr
        bn

        " if we circled around to the beginning, go back
        if bufnr("%") < l:bufnr
            bp
        endif

        " re-delete our original buffer
        exec "bd " . l:bufnr
    endif
endfunction

noremap  <C-W>      :call DeleteCurrentBuffer()<CR>
inoremap <C-W> <ESC>:call DeleteCurrentBuffer()<CR>

" ctrl+left and ctrl+right should do the right thing in normal mode
noremap  <C-LEFT>  b
noremap  <C-RIGHT> e

" ctrl+shift+left and ctrl+shift+right should do the right thing
noremap  <C-S-LEFT> vb<C-G>
inoremap <C-S-LEFT> <C-\><C-O>vb<C-G>
vnoremap <C-S-LEFT> b

noremap  <C-S-RIGHT> ve<C-G>
inoremap <C-S-RIGHT> <C-\><C-O>ve<C-G>
vnoremap <C-S-RIGHT> e

" shift+j and shift+k should move by pages
nnoremap <S-J> <PageDown>
nnoremap <S-K> <PageUp>

xnoremap <S-J> <S-PageDown>
xnoremap <S-K> <S-PageUp>

""""""""""""""""""""""""""""""""""""""""""""""""""
" Find & Replace
"

function! FindAndReplace(highlight)
    if matchstr(a:highlight, "\n") != ""
        " this should work, but vim doesn't like the `s
        " let @h = "`<,`>s//"
        let @h = '%s/\%V/'
    else
        let @h = "%s/" . escape(a:highlight, "./") . "//"
    endif
endfunction

noremap  <C-H>      :%s/<C-R><C-W>//<Left>
inoremap <C-H> <C-O>:%s/<C-R><C-W>//<Left>
vnoremap <C-H> "hy:exec 'call FindAndReplace("' . escape(escape(@h, '"\'), '"\/') . '")'<CR>:<C-R>h<Left>

""""""""""""""""""""""""""""""""""""""""""""""""""
" Plugins
"

" edit the snippets file for the current filetype
noremap  <C-F2>      :exec "edit " . snippets_dir . &ft . ".snippets"<CR>
inoremap <C-F2> <C-O>:exec "edit " . snippets_dir . &ft . ".snippets"<CR>
vnoremap <C-F2> <C-C>:exec "edit " . snippets_dir . &ft . ".snippets"<CR>

" mini buffer explorer
let g:miniBufExplMapCTabSwitchBufs = 1
let g:miniBufExplCheckDupeBufs     = 0

" filetype switching
augroup SourceHeaderPairs
    autocmd BufEnter *.cpp,*.cxx,*.cc,*.c let b:fswitchdst  = "h,hpp"
    autocmd BufEnter *.hpp,*.hxx,*.h      let b:fswitchdst  = "cpp,cxx,cc,c"
    autocmd BufEnter *                    let b:fswitchlocs = "./"
augroup end

noremap  <C-F10>      :FSHere<CR>
inoremap <C-F10> <C-O>:FSHere<CR>
vnoremap <C-F10> <C-C>:FSHere<CR>

" delimit helpers
let g:delimitMate_expand_cr = 1

" commenting
let g:NERDCreateDefaultMappings = 0
let g:NERDSpaceDelims           = 1

noremap  <silent> <C-K>      :call NERDComment("n", "alignBoth")<CR>
inoremap <silent> <C-K> <C-O>:call NERDComment("n", "alignBoth")<CR>
xnoremap <silent> <C-K> <C-C>:call NERDComment("x", "alignBoth")<CR>gv
snoremap <silent> <C-K> <C-C>:call NERDComment("x", "alignBoth")<CR>gv<C-G>

noremap  <silent> <C-J>      :call NERDComment("n", "uncomment")<CR>
inoremap <silent> <C-J> <C-O>:call NERDComment("n", "uncomment")<CR>
xnoremap <silent> <C-J> <C-C>:call NERDComment("x", "uncomment")<CR>gv
snoremap <silent> <C-J> <C-C>:call NERDComment("x", "uncomment")<CR>gv<C-G>

let g:loaded_comment = 1

" tab alignment
function! TabAlign(arg)
    let l:cursor = getpos('.')
    exec "Tabularize " . a:arg
    call setpos('.', l:cursor)
endfunction

noremap  <silent> <Leader>a=      :call TabAlign('/=')<CR>
inoremap <silent> <Leader>a= <C-O>:call TabAlign('/=')<CR>
noremap  <silent> <Leader>a:      :call TabAlign('/:\zs/l0l1')<CR>
inoremap <silent> <Leader>a: <C-O>:call TabAlign('/:\zs/l0l1')<CR>

" conque
noremap  <C-Space>      :ConqueTerm cmd<CR>
inoremap <C-Space> <C-O>:ConqueTerm cmd<CR>

" let g:miniBufExplorerDebugLevel = 10 " MBE reports everything
" let g:miniBufExplorerDebugMode  = 0  " Errors will show up in 

""""""""""""""""""""""""""""""""""""""""""""""""""
" Autocommands
"

" when editing a file, jump to the last cursor position
autocmd BufReadPost * call RestorePosition()
function! RestorePosition()
    if line("'\"") <= line("$")
        execute "normal `\""
    else
        execute "normal $"
    endif
endfunction

" override vim's default ftplugins for indenting our text
autocmd FileType * set formatoptions-=o
autocmd FileType * set formatoptions-=r

""""""""""""""""""""""""""""""""""""""""""""""""""
" Other Environments
"

if filereadable($HOME . "/work.vim")
    source $HOME/work.vim
endif

